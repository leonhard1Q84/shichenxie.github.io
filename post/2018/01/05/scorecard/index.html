<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Hugo 0.55.6" />


<title>使用R语言开发评分卡模型 - 谢士晨 | Shichen Xie</title>
<meta property="og:title" content="使用R语言开发评分卡模型 - 谢士晨 | Shichen Xie">



  








<link href='//cdn.bootcss.com/highlight.js/9.11.0/styles/github.min.css' rel='stylesheet' type='text/css' />



<link rel="stylesheet" href="../../../../../css/fonts.css" media="all">
<link rel="stylesheet" href="../../../../../css/main.css" media="all">



  </head>
  <body>
    <div class="wrapper">
      <header class="header">
        <nav class="nav">
  <a href="../../../../../" class="nav-logo">
    <img src="../../../../../images/logo.png"
         width="50"
         height="50"
         alt="Logo">
  </a>

  <ul class="nav-links">
    
    <li><a href="../../../../../about/">关于</a></li>
    
    <li><a href="../../../../../">博客</a></li>
    
    <li><a href="http://shichen.name/scorecard/">scorecard</a></li>
    
    <li><a href="http://shichen.name/pedquant/">pedquant</a></li>
    
  </ul>
</nav>

      </header>


<main class="content" role="main">

  <article class="article">
    
    <span class="article-duration">3 min read</span>
    

    <h1 class="article-title">使用R语言开发评分卡模型</h1>

    
    <span class="article-date">2018/01/05</span>
    

    <div class="article-content">
      


<p>为了提高评分卡模型的开发效率，我为 R 语言社区贡献了一个开源项目 scorecard 包 (<a href="http://github.com/shichenXie/scorecard">Github</a>, <a href="https://cran.r-project.org/web/packages/scorecard/index.html">CRAN</a>)。该 R 包提供了评分卡开发过程中的常用功能，包括变量粗筛、分箱与woe转换、模型评估、评分刻度转换等。</p>
<p>评分卡模型的开发流程通常包括以下五个主要步骤：数据准备、WOE分箱、模型拟合、模型评估、评分卡刻度。下面结合 scorecard 包完成一个简单的评分卡模型开发案例。更加详细的评分卡模型开发介绍请参考<a href="http://shichen.name/slide/20171115scorecard/">幻灯片</a>。</p>
<div id="数据准备" class="section level2">
<h2>数据准备</h2>
<p>首先加载 scorecard 包，并载入包内自带的德国信贷数据集。该数据集包含了1000个借款人的信贷数据，20个 X 特征与1个 Y 值。其详细信息参见 <a href="https://archive.ics.uci.edu/ml/datasets/Statlog+(German+Credit+Data)">UCI 的德国信贷数据集网站</a>。</p>
<pre class="r"><code>library(scorecard)

# load germancredit data
data(germancredit)</code></pre>
<p>载入数据集后，可先通过变量的 IV 值、缺失率以及单类别率对 X 特征进行初步筛选。var_filter 函数默认删除信息值小于0.02、缺失率大于95%或单类别比例大于95%的变量。var_filter 函数还能够人为设定需要删除或保留的变量，以及够返回变量删除的原因列表。</p>
<pre class="r"><code># filter variable via missing rate, iv, identical rate
dt = var_filter(germancredit, y = &#39;creditability&#39;)</code></pre>
<pre><code>## [INFO] filtering variables ...</code></pre>
<p>将经过初筛的数据集拆分为训练集与测试集。在 split_df 函数中如果指定了 y 变量，那么将基于 y 变量分层拆分，如果没有指定，则随机拆分数据集。ratio 为拆分后两个数据集的样本量占比。 seed 为随机种子，用于重现拆分的样本。</p>
<pre class="r"><code># breaking dt into train and test
dt_list = split_df(dt, y=&quot;creditability&quot;, ratio = 0.6, seed = 30)
label_list = lapply(dt_list, function(x) x$creditability)</code></pre>
</div>
<div id="woe分箱" class="section level2">
<h2>WOE分箱</h2>
<p>接下来对数据集进行分箱与 woe 值转换。由于这个数据集样本量比较小，我们可以直接对全样本进行分箱处理。如果数据量允许，应该使用训练集进行分箱，并使用训练集得到的 woe 值对其他数据集进行woe替换。</p>
<p>woebin 函数提供了树形 tree、卡方合并 chimerge、等宽 width 与等高 freq 四种分箱方法。以树形分箱为例，默认情形是当信息值增益率 stop_limit 小于0.1, 或分箱数 bin_num_limit 大于8(缺失值除外)时停止分箱，同时确保每一个分箱的样本占比 count_distr_limit 不小于5%。当然还能够通过 breaks_list 手动设定分箱节点。</p>
<p>woebin 函数输出的结果为多个 data.frame 组成的 list，可通过 data.table::rbindlist 或 dplyr::bind_rows 函数合并为一个数据框然后保存。当然 woebin 函数也能够直接输出一个由分箱切割点组成的 list 并保存，下次使用时直接通过 woebin 函数对 breaks_list 参数对新的数据集进行分箱。</p>
<p>woebin_adj 函数可逐个观察每个变量的分箱情况。如果不满意默认的分箱结果，可以手动修改。最终返回一个经过手动调整的分箱节点。</p>
<p>分箱之后，需要使用 woebin_ply 函数将训练集与测试集转换为对应的 woe 值。</p>
<pre class="r"><code># woe binning 
bins = woebin(dt, &quot;creditability&quot;, print_step=0)</code></pre>
<pre><code>## [INFO] creating woe binning ...</code></pre>
<pre class="r"><code>bins[[12]]</code></pre>
<pre><code>##                   variable           bin count count_distr good bad badprob     woe  bin_iv total_iv        breaks
## 1: other.installment.plans bank%,%stores   186       0.186  110  76  0.4086  0.4776 0.04594  0.05759 bank%,%stores
## 2: other.installment.plans          none   814       0.814  590 224  0.2752 -0.1212 0.01166  0.05759          none
##    is_special_values
## 1:             FALSE
## 2:             FALSE</code></pre>
<pre class="r"><code>woebin_plot(bins[[12]])</code></pre>
<pre><code>## $other.installment.plans</code></pre>
<p><img src="../../../../../post/2018-01-05-scorecard_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<pre class="r"><code># converting train and test into woe values
dt_woe_list = lapply(dt_list, function(x) woebin_ply(x, bins))</code></pre>
<pre><code>## [INFO] converting into woe values ...</code></pre>
</div>
<div id="模型拟合" class="section level2">
<h2>模型拟合</h2>
<p>当获得了 woe 值替换之后的数据集，可以使用逻辑回归进行拟合，并通过AIC、LASSO等方法对变量进一步筛选。下面使用基于 AIC 的逐步回归进一步筛选变量，最终得到了一个拥有13个变量的模型。</p>
<pre class="r"><code># lr
m1 = glm( creditability ~ ., family = binomial(), data = dt_woe_list$train)
# vif(m1, merge_coef = TRUE) # summary(m1)

# Select a formula-based model by AIC (or by LASSO for large dataset)
m_step = step(m1, direction=&quot;both&quot;, trace = FALSE)
m2 = eval(m_step$call)
vif(m2, merge_coef = TRUE) # summary(m2)</code></pre>
<pre><code>##                                                    variable Estimate Std. Error z value Pr(&gt;|z|)  gvif
##  1:                                             (Intercept)  -0.9448     0.1094  -8.639   0.0000    NA
##  2:                 status.of.existing.checking.account_woe   0.7756     0.1380   5.619   0.0000 1.042
##  3:                                   duration.in.month_woe   0.7963     0.2291   3.476   0.0005 1.181
##  4:                                      credit.history_woe   0.8308     0.2035   4.082   0.0000 1.064
##  5:                                             purpose_woe   0.8632     0.2755   3.133   0.0017 1.043
##  6:                                       credit.amount_woe   0.7669     0.2838   2.702   0.0069 1.251
##  7:                           savings.account.and.bonds_woe   0.8545     0.2606   3.279   0.0010 1.039
##  8: installment.rate.in.percentage.of.disposable.income_woe   1.8621     0.6822   2.730   0.0063 1.094
##  9:                         other.debtors.or.guarantors_woe   2.1018     0.8922   2.356   0.0185 1.037
## 10:                                        age.in.years_woe   1.0154     0.3001   3.383   0.0007 1.033
## 11:                             other.installment.plans_woe   0.7623     0.4347   1.754   0.0795 1.060
## 12:                                             housing_woe   0.7610     0.3665   2.077   0.0378 1.035</code></pre>
</div>
<div id="模型评估" class="section level2">
<h2>模型评估</h2>
<p>通过逻辑回归获得各变量的拟合系数之后，可以计算出各个样本为坏客户的概率，然后评估模型的预测效果。 perf_eva 函数能够计算的评估指标包括 mse, rmse, logloss, r2, ks, auc, gini，以及绘制多种可视化图形 ks, lift, gain, roc, lz, pr, f1, density。</p>
<pre class="r"><code>## predicted proability
pred_list = lapply(dt_woe_list, function(x) predict(m2, x, type=&#39;response&#39;))

## performance
perf = perf_eva(pred = pred_list, label = label_list)</code></pre>
<pre><code>## [INFO] The threshold of confusion matrix is 0.3133.</code></pre>
<p><img src="../../../../../post/2018-01-05-scorecard_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
</div>
<div id="评分卡刻度" class="section level2">
<h2>评分卡刻度</h2>
<p>当我们获得了各个变量的分箱结果，并且确定了最终进入模型的变量以及系数，则可以创建标准评分卡。</p>
<p>有了评分卡之后，可用于对新样本进行打分，从而评估该客户的信用水平，并最终作出审批决策。</p>
<p>最后，评分卡模型的开发过程，还需要对模型的稳定性进行评估，即计算psi。</p>
<pre class="r"><code>## scorecard
card = scorecard(bins, m2)
## credit score
score_list = lapply(dt_list, function(x) scorecard_ply(x, card))

## psi
perf_psi(score = score_list, label = label_list)</code></pre>
<pre><code>## $psi
## Null data.table (0 rows and 0 cols)</code></pre>
<p>以上代码均可以在该项目的<a href="http://shichen.name/scorecard/">主页</a>获取。</p>
</div>

    </div>
  </article>

  
<section id="comments">
  <div id="disqus_thread"></div>
  <script>
  
  (function() {
   var inIFrame = function() {
      var iframe = true;
      try { iframe = window.self !== window.top; } catch (e) {}
      return iframe;
    };
    if (inIFrame()) return;
    var d = document, s = d.createElement('script');
    s.src = '//shichen.disqus.com/embed.js'; s.async = true;
    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</section>


</main>

      <footer class="footer">
        <ul class="footer-links">
          <li>
            <a href="https://github.com/shichenxie" class="footer-links-kudos">GitHub</a>
          </li>
          <li>
            <a href="../../../../../index.xml" type="application/rss+xml" target="_blank">RSS feed</a>
          </li>
        </ul>
      </footer>

    </div>
    



<script src="//cdn.bootcss.com/highlight.js/9.11.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.11.0/languages/yaml.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



    
<script src="../../../../../js/math-code.js"></script>
<script async src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>


    
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-97064288-1', 'auto');
	
	ga('send', 'pageview');
}
</script>

  </body>
</html>

